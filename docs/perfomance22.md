[Обратно](README.md)

**Оглавление:**

[[_TOC_]]

# Алгоритм сжатия видео данных для автономного накопителя

## Первый слайд с названием работы
## Коротко о том что я делаю (слайд1 картинка с камерой)

Целью моей исследовательской работы является разработка разработка алгоритма
сжатия видео данных для автономного накопителя. В прошлый раз я рассказывал про
то, какие алгоритмы я использую для того чтобы сжимать видеопоток данных с
автономного носителя.
В этот раз я хочу углубиться в эту тему и рассказать, чего
мне удалось достичь в этой теме за несколько месяцев исследования данной темы:

## Использование дискретного косинусного преобразования
Дискретное косинусное преобразование (DCT - Discrete Cosine Transform). Является
одним из ортогональных преобразований. Это преобразование очень часто
используется в различных алгоритмах сжатия изображения таких как MPEG или JPEG

Формула прямого дискретного косинусного преобразования:
```math
F(u, v) = \frac{1}{4} C(u)C(v) \sum^{N-1}_{x=0} \sum^{N-1}_{y=0} f(x, y) \cos
\frac{ (2x+1)u \pi }{2N} \cos \frac{ (2x+1)v \pi }{2N} \\
C(u), C(v) = 1 / \sqrt{2} \; \; for \; u, v = 0 \\
C(u), C(v) = 1 \; \; else \\
N = \text{Размер блока}
```

Обратное косинусное преобразование определено следующим образом:
```math
f(x, y) = \frac{1}{4} C(u)C(v) \sum^{N-1}_{x=0} \sum^{N-1}_{y=0} f(x, y)
F(u, v) \cos \frac{(2y+1)u \pi}{16} \cos \frac{(2y+1)v \pi}{16}
```

## Почему мы не используем обычный DCT

Но на самом деле это преобразование в настоящих кодерах и декодерах
используется довольно редко, потому что вычисления довольно дороги, особенно в
потоковых кодерах, а сложность кодирования непропорционально возрастает:
```math
O(N^2)
```

По этой причине изображения, сжатые с помощью DCT, разделяются на блоки. Другой
Недостатком DCT является невозможность разложить широкий сигнал на высокие и низкие частоты одновременно.

<!-- Подводка к стандарту H.265 -->

## Пример DCT на конкретном изображении

В первой версии своей программы я разрабатывал код для кодирования и
декодирования блока с помощью дискретного косинусного преобразования. В новой
версии реализовал кодирование и декодирование с помощью быстрого DCT (FDCT).

## Дальнейшее изучение обработки изображений

## Компенсация движения

1. Кадр делится на блоки (например 16×16).
2. Производится обход блоков (каждый блок в данном случае обрабатывается отдельно)
3. При счете одного блока производится обход некоторой окрестности блока в
   поиске максимального соответствия изображению блока на предыдущем кадре в
   пределах этой окрестности.
4. Таким образом, после завершения поиска мы получаем набор векторов,
   указывающий «движение» блоков изображения между кадрами. Эти векторы могут
   быть естественным образом использованы для создания изображения
   скомпенсированного кадра, который лучше приближает кадр, для которого
   производилась компенсация движения.

<!--  image 10.1 Macroblocks motions compensation -->

Разница между двумя блоками (MED - Mean Absolute Difference) называется средняя
абсолютная разница между двумя блоками.

```math
MAD(i, j) = \frac{1}{N^2} \sum^{N-1}_{k = 0} \sum^{N-1}_{l = 0}
\left| C(x + k, y + l) - R(x + i + k, y + j + l) \right| \\
N - \text{Размер макроблока} \\
k, l - \text{Индексы пикселей в изображении} \\
i, j - \text{Горизонтальное и вертикальное смещение} \\
C(x + k, y + l) - \text{Пиксели макроблока в текущем изображении} \\
R(x + i + k, y + j + l) - \text{Пиксели макроблока в опорном изображении}
```

Задачей является найти минимальный вектор движения:

```math
(u, v) = [(i, j) \; | \; MAD(i, j) = min]
```
### Последовательный поиск

Макроблок, центрированный в каждой из позиций в окне, сравнивается с макроблоком
в целевом кадре пиксель за пикселем с учетом MAD, затем выводится с
использованием формулы из предыдущего слайда.

Метод последовательного поиска не самый лучший алгоритм. Его использование
довольно-таки дорогостоящее. Для каждого сравнения пикселей требуется три
операции (вычитание, нахождение абсолютного значения, сложение). Сложность
получения вектора движения одного макроблока составляет:

```math
(2p+1) \cdot (2p+1) \cdot N^2 \cdot 3 = O(p^2N^2)
```

Это слишком много для автономного устройства, каждое вычисление требует энергии
от аккумулятора, чем больше вычислений, тем устройство менее автономно. Ну и
естественно для обеспечения автономности оно не будет обладать
большими вычислительными мощностями.

### Двухмерный логарифмический поиск
Это более дешевая по энергозатратам версия, но до сих пор не оптимальная. Хотя
обычно довольно эффективная.

Процедура двумерного логарифмического поиска векторов движения занимает
несколько итераций и похожа на двоичный поиск:

<!-- картинка 10.2 двоичный поиск -->

1. Как показано на рисунке 10.2, первоначально только девять местоположений в
   окне поиска используются в качестве начальных значений для поиска на основе
   MAD; они помечены цифрой «1».
2. После того, как найден тот, который дает минимальное MAD, центр новой области
   поиска перемещается в него, а размер шага («смещение») уменьшается до
   половины.
3. На следующей итерации девять новых местоположений помечаются цифрой «2» и так
   далее на следующих итерациях.

Используя тот же пример, что и в предыдущем подразделе, общее количество
операций в секунду снижается до:
```math
    OPS\_per\_second = 1.25 \cdot10^9
```

### Иерархический поиск
Для поиска может быть полезен иерархический (с множественным разрешением)
подход, при котором начальная оценка вектора движения может быть получена из
изображений со значительно уменьшенным разрешением.

<!-- Картинка 10.3 -->

Трехуровневый иерархический поиск, в котором исходное изображение находится на
Уровне 0, изображения на Уровнях 1 и 2 получаются понижающей дискретизацией от
предыдущих уровней с коэффициентом 2, а начальный поиск проводится на Уровне 2 .

Из-за уменьшения картинки,  пропорционально уменьшается количество требуемых
операций для поиска.

### Сравнительная таблица 

| Метод поиска                     | p = 15               | p = 7 |
| -------------------------------- |:--------------------:| -------------------:|
| Последовательный поиск           | $`28.89 \cdot 10^9`$ | $`7.00 \cdot 10^9`$ |
| Двухмерный логарифмический поиск | $`1.25 \cdot 10^9`$  | $`0.78 \cdot 10^9`$ |
| 3-х мерный иерархический поиск   | $`0.51 \cdot 10^9`$  | $`0.40 \cdot 10^9`$ |

$`OPS\_per\_second`$ приведен для кадра 720х480 пикселей при частоте кадров в
30 кадров в секунду

### Что я буду делать дальше

После расчета DCT следующий шаг включает поиск и отбрасывание коэффициентов,
вклад которых в формирование изображения минимален.
На этапе квантования сжатия изображения происходит отбрасывание коэффициентов
дискретного косинусного преобразования, которые несущественны для восстановления
изображения, достаточно близкого к оригиналу. Квантование – основной процесс,
при выполнении которого теряются данные в методе JPEG- сжатия.

Мною были проанализированны различные виды алгоритмы компенсаций движения, среди
них будет выбран оптимальный для моего случая использования и реализован в
дальнейшем.


## Использованная литература

* Digital Video and HDTV Algorithms and Interfaces by C.A. Poynton
* Video Coding: An introduction to standard codecs by M. Ghanbari
* Video processing and communications by Y. Wangetal.
